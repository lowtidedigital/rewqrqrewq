{
  "version": 3,
  "sources": ["../../src/lib/dynamodb.ts", "../../src/lib/utils.ts", "../../node_modules/uuid/dist/esm-node/rng.js", "../../node_modules/uuid/dist/esm-node/stringify.js", "../../node_modules/uuid/dist/esm-node/native.js", "../../node_modules/uuid/dist/esm-node/v4.js", "../../src/handlers/redirect.ts"],
  "sourcesContent": ["// DynamoDB client and utility functions\nimport { DynamoDBClient } from '@aws-sdk/client-dynamodb';\nimport { \n  DynamoDBDocumentClient, \n  GetCommand, \n  PutCommand, \n  UpdateCommand, \n  QueryCommand, \n  DeleteCommand,\n  TransactWriteCommand\n} from '@aws-sdk/lib-dynamodb';\nimport type { Link, ClickEvent } from '../types/index.js';\n\nconst client = new DynamoDBClient({});\nexport const docClient = DynamoDBDocumentClient.from(client, {\n  marshallOptions: {\n    removeUndefinedValues: true,\n  },\n});\n\nconst LINKS_TABLE = process.env.LINKS_TABLE!;\nconst ANALYTICS_TABLE = process.env.ANALYTICS_TABLE!;\nconst AGGREGATES_TABLE = process.env.AGGREGATES_TABLE!;\n\n// =============================================================================\n// LINK OPERATIONS\n// =============================================================================\n\nexport async function getLinkBySlug(slug: string): Promise<Link | null> {\n  // First get the slug mapping\n  const slugResult = await docClient.send(new GetCommand({\n    TableName: LINKS_TABLE,\n    Key: {\n      PK: `SLUG#${slug}`,\n      SK: 'METADATA',\n    },\n  }));\n\n  if (!slugResult.Item) {\n    return null;\n  }\n\n  const { linkId, userId } = slugResult.Item;\n\n  // Then get the full link data\n  const linkResult = await docClient.send(new GetCommand({\n    TableName: LINKS_TABLE,\n    Key: {\n      PK: `USER#${userId}`,\n      SK: `LINK#${linkId}`,\n    },\n  }));\n\n  if (!linkResult.Item) {\n    return null;\n  }\n\n  return itemToLink(linkResult.Item);\n}\n\nexport async function getLinkById(userId: string, linkId: string): Promise<Link | null> {\n  const result = await docClient.send(new GetCommand({\n    TableName: LINKS_TABLE,\n    Key: {\n      PK: `USER#${userId}`,\n      SK: `LINK#${linkId}`,\n    },\n  }));\n\n  if (!result.Item) {\n    return null;\n  }\n\n  return itemToLink(result.Item);\n}\n\nexport async function listLinksByUser(\n  userId: string, \n  options: { limit?: number; nextToken?: string; search?: string } = {}\n): Promise<{ links: Link[]; nextToken?: string }> {\n  const { limit = 50, nextToken, search } = options;\n\n  const result = await docClient.send(new QueryCommand({\n    TableName: LINKS_TABLE,\n    KeyConditionExpression: 'PK = :pk AND begins_with(SK, :skPrefix)',\n    FilterExpression: search \n      ? 'contains(title, :search) OR contains(slug, :search) OR contains(longUrl, :search)'\n      : undefined,\n    ExpressionAttributeValues: {\n      ':pk': `USER#${userId}`,\n      ':skPrefix': 'LINK#',\n      ...(search ? { ':search': search } : {}),\n    },\n    Limit: limit,\n    ExclusiveStartKey: nextToken ? JSON.parse(Buffer.from(nextToken, 'base64').toString()) : undefined,\n    ScanIndexForward: false, // Most recent first\n  }));\n\n  return {\n    links: (result.Items || [])\n      .map(itemToLink)\n      .filter((link): link is Link => link !== null && !link.deletedAt),\n    nextToken: result.LastEvaluatedKey \n      ? Buffer.from(JSON.stringify(result.LastEvaluatedKey)).toString('base64')\n      : undefined,\n  };\n}\n\nexport async function createLink(link: Link): Promise<void> {\n  // Use a transaction to create both the link and slug mapping atomically\n  await docClient.send(new TransactWriteCommand({\n    TransactItems: [\n      {\n        Put: {\n          TableName: LINKS_TABLE,\n          Item: {\n            PK: `USER#${link.userId}`,\n            SK: `LINK#${link.id}`,\n            GSI1PK: `USER#${link.userId}`,\n            GSI1SK: `CREATED#${link.createdAt}`,\n            ...linkToItem(link),\n          },\n          ConditionExpression: 'attribute_not_exists(PK)',\n        },\n      },\n      {\n        Put: {\n          TableName: LINKS_TABLE,\n          Item: {\n            PK: `SLUG#${link.slug}`,\n            SK: 'METADATA',\n            linkId: link.id,\n            userId: link.userId,\n          },\n          ConditionExpression: 'attribute_not_exists(PK)',\n        },\n      },\n    ],\n  }));\n}\n\nexport async function updateLink(link: Link, oldSlug?: string): Promise<void> {\n  const transactItems: any[] = [\n    {\n      Put: {\n        TableName: LINKS_TABLE,\n        Item: {\n          PK: `USER#${link.userId}`,\n          SK: `LINK#${link.id}`,\n          GSI1PK: `USER#${link.userId}`,\n          GSI1SK: `CREATED#${link.createdAt}`,\n          ...linkToItem(link),\n        },\n      },\n    },\n  ];\n\n  // If slug changed, update the slug mapping\n  if (oldSlug && oldSlug !== link.slug) {\n    transactItems.push(\n      {\n        Delete: {\n          TableName: LINKS_TABLE,\n          Key: {\n            PK: `SLUG#${oldSlug}`,\n            SK: 'METADATA',\n          },\n        },\n      },\n      {\n        Put: {\n          TableName: LINKS_TABLE,\n          Item: {\n            PK: `SLUG#${link.slug}`,\n            SK: 'METADATA',\n            linkId: link.id,\n            userId: link.userId,\n          },\n          ConditionExpression: 'attribute_not_exists(PK)',\n        },\n      }\n    );\n  }\n\n  await docClient.send(new TransactWriteCommand({ TransactItems: transactItems }));\n}\n\nexport async function softDeleteLink(userId: string, linkId: string): Promise<void> {\n  const link = await getLinkById(userId, linkId);\n  if (!link) return;\n\n  const now = Date.now();\n  \n  await docClient.send(new TransactWriteCommand({\n    TransactItems: [\n      {\n        Update: {\n          TableName: LINKS_TABLE,\n          Key: {\n            PK: `USER#${userId}`,\n            SK: `LINK#${linkId}`,\n          },\n          UpdateExpression: 'SET deletedAt = :deletedAt, updatedAt = :updatedAt',\n          ExpressionAttributeValues: {\n            ':deletedAt': now,\n            ':updatedAt': now,\n          },\n        },\n      },\n      {\n        Delete: {\n          TableName: LINKS_TABLE,\n          Key: {\n            PK: `SLUG#${link.slug}`,\n            SK: 'METADATA',\n          },\n        },\n      },\n    ],\n  }));\n}\n\nexport async function checkSlugAvailable(slug: string): Promise<boolean> {\n  const result = await docClient.send(new GetCommand({\n    TableName: LINKS_TABLE,\n    Key: {\n      PK: `SLUG#${slug}`,\n      SK: 'METADATA',\n    },\n  }));\n\n  return !result.Item;\n}\n\nexport async function incrementClickCount(userId: string, linkId: string): Promise<void> {\n  await docClient.send(new UpdateCommand({\n    TableName: LINKS_TABLE,\n    Key: {\n      PK: `USER#${userId}`,\n      SK: `LINK#${linkId}`,\n    },\n    UpdateExpression: 'SET clickCount = if_not_exists(clickCount, :zero) + :inc',\n    ExpressionAttributeValues: {\n      ':zero': 0,\n      ':inc': 1,\n    },\n  }));\n}\n\n// =============================================================================\n// ANALYTICS OPERATIONS\n// =============================================================================\n\nexport async function recordClickEvent(event: ClickEvent): Promise<void> {\n  const date = new Date(event.timestamp);\n  const monthKey = `${date.getUTCFullYear()}-${String(date.getUTCMonth() + 1).padStart(2, '0')}`;\n\n  await docClient.send(new PutCommand({\n    TableName: ANALYTICS_TABLE,\n    Item: {\n      PK: `LINK#${event.linkId}#${monthKey}`,\n      SK: `TS#${event.timestamp}#${event.eventId}`,\n      GSI1PK: `USER#${event.userId}#${monthKey}`,\n      GSI1SK: `TS#${event.timestamp}`,\n      ...event,\n      ttl: Math.floor(Date.now() / 1000) + (365 * 24 * 60 * 60 * 2), // 2 years\n    },\n  }));\n\n  // Update aggregates\n  await updateAggregates(event);\n}\n\nasync function updateAggregates(event: ClickEvent): Promise<void> {\n  const date = new Date(event.timestamp);\n  const dayKey = date.toISOString().split('T')[0];\n  const monthKey = `${date.getUTCFullYear()}-${String(date.getUTCMonth() + 1).padStart(2, '0')}`;\n\n  // Update link daily aggregate\n  await docClient.send(new UpdateCommand({\n    TableName: AGGREGATES_TABLE,\n    Key: {\n      PK: `LINK#${event.linkId}`,\n      SK: `AGG#daily#${dayKey}`,\n    },\n    UpdateExpression: 'SET clicks = if_not_exists(clicks, :zero) + :inc, lastUpdated = :now',\n    ExpressionAttributeValues: {\n      ':zero': 0,\n      ':inc': 1,\n      ':now': Date.now(),\n    },\n  }));\n\n  // Update link total\n  await docClient.send(new UpdateCommand({\n    TableName: AGGREGATES_TABLE,\n    Key: {\n      PK: `LINK#${event.linkId}`,\n      SK: 'AGG#total',\n    },\n    UpdateExpression: 'SET clicks = if_not_exists(clicks, :zero) + :inc, lastUpdated = :now',\n    ExpressionAttributeValues: {\n      ':zero': 0,\n      ':inc': 1,\n      ':now': Date.now(),\n    },\n  }));\n\n  // Update user monthly aggregate\n  await docClient.send(new UpdateCommand({\n    TableName: AGGREGATES_TABLE,\n    Key: {\n      PK: `USER#${event.userId}`,\n      SK: `AGG#monthly#${monthKey}`,\n    },\n    UpdateExpression: 'SET clicks = if_not_exists(clicks, :zero) + :inc, lastUpdated = :now',\n    ExpressionAttributeValues: {\n      ':zero': 0,\n      ':inc': 1,\n      ':now': Date.now(),\n    },\n  }));\n}\n\nexport async function getClickEvents(\n  linkId: string, \n  options: { startDate?: number; endDate?: number; limit?: number } = {}\n): Promise<ClickEvent[]> {\n  const { startDate, endDate = Date.now(), limit = 100 } = options;\n\n  // Query across month partitions\n  const now = new Date(endDate);\n  const start = startDate ? new Date(startDate) : new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);\n\n  const events: ClickEvent[] = [];\n  let currentDate = new Date(start);\n\n  while (currentDate <= now && events.length < limit) {\n    const monthKey = `${currentDate.getUTCFullYear()}-${String(currentDate.getUTCMonth() + 1).padStart(2, '0')}`;\n\n    const result = await docClient.send(new QueryCommand({\n      TableName: ANALYTICS_TABLE,\n      KeyConditionExpression: 'PK = :pk AND SK BETWEEN :start AND :end',\n      ExpressionAttributeValues: {\n        ':pk': `LINK#${linkId}#${monthKey}`,\n        ':start': `TS#${start.getTime()}`,\n        ':end': `TS#${endDate}`,\n      },\n      Limit: limit - events.length,\n      ScanIndexForward: false,\n    }));\n\n    events.push(...(result.Items || []).map(item => ({\n      eventId: item.eventId,\n      linkId: item.linkId,\n      slug: item.slug,\n      userId: item.userId,\n      timestamp: item.timestamp,\n      referrer: item.referrer,\n      userAgent: item.userAgent,\n      country: item.country,\n      device: item.device,\n      ipHash: item.ipHash,\n    })));\n\n    // Move to next month\n    currentDate.setUTCMonth(currentDate.getUTCMonth() + 1);\n    currentDate.setUTCDate(1);\n  }\n\n  return events.slice(0, limit);\n}\n\nexport async function getLinkAggregates(linkId: string): Promise<{\n  total: number;\n  daily: { date: string; clicks: number }[];\n}> {\n  const result = await docClient.send(new QueryCommand({\n    TableName: AGGREGATES_TABLE,\n    KeyConditionExpression: 'PK = :pk AND begins_with(SK, :prefix)',\n    ExpressionAttributeValues: {\n      ':pk': `LINK#${linkId}`,\n      ':prefix': 'AGG#',\n    },\n  }));\n\n  let total = 0;\n  const daily: { date: string; clicks: number }[] = [];\n\n  for (const item of result.Items || []) {\n    if (item.SK === 'AGG#total') {\n      total = item.clicks || 0;\n    } else if (item.SK.startsWith('AGG#daily#')) {\n      daily.push({\n        date: item.SK.replace('AGG#daily#', ''),\n        clicks: item.clicks || 0,\n      });\n    }\n  }\n\n  return { total, daily: daily.sort((a, b) => a.date.localeCompare(b.date)) };\n}\n\n// =============================================================================\n// HELPER FUNCTIONS\n// =============================================================================\n\nfunction linkToItem(link: Link): Record<string, any> {\n  return {\n    id: link.id,\n    userId: link.userId,\n    slug: link.slug,\n    longUrl: link.longUrl,\n    title: link.title,\n    tags: link.tags,\n    notes: link.notes,\n    enabled: link.enabled,\n    privacyMode: link.privacyMode,\n    redirectType: link.redirectType,\n    expiresAt: link.expiresAt,\n    createdAt: link.createdAt,\n    updatedAt: link.updatedAt,\n    deletedAt: link.deletedAt,\n    clickCount: link.clickCount,\n    qrPngKey: link.qrPngKey,\n    qrSvgKey: link.qrSvgKey,\n    qrUpdatedAt: link.qrUpdatedAt,\n  };\n}\n\nfunction itemToLink(item: Record<string, any>): Link | null {\n  if (!item) return null;\n\n  return {\n    id: item.id,\n    userId: item.userId,\n    slug: item.slug,\n    longUrl: item.longUrl,\n    title: item.title,\n    tags: item.tags,\n    notes: item.notes,\n    enabled: item.enabled ?? true,\n    privacyMode: item.privacyMode ?? false,\n    redirectType: item.redirectType ?? 302,\n    expiresAt: item.expiresAt,\n    createdAt: item.createdAt,\n    updatedAt: item.updatedAt,\n    deletedAt: item.deletedAt,\n    clickCount: item.clickCount ?? 0,\n    qrPngKey: item.qrPngKey,\n    qrSvgKey: item.qrSvgKey,\n    qrUpdatedAt: item.qrUpdatedAt,\n  };\n}\n", "// Utility functions for Lambda handlers\n\nimport { createHash, randomBytes } from 'crypto';\n\n// Base62 characters for slug generation\nconst BASE62_CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';\n\n/**\n * Generate a random base62 slug\n */\nexport function generateSlug(length: number = 7): string {\n  const bytes = randomBytes(length);\n  let result = '';\n  \n  for (let i = 0; i < length; i++) {\n    result += BASE62_CHARS[bytes[i] % 62];\n  }\n  \n  return result;\n}\n\n/**\n * Validate a custom slug format\n */\nexport function isValidSlug(slug: string): boolean {\n  // Only allow alphanumeric and hyphens, 3-50 chars\n  return /^[a-zA-Z0-9][a-zA-Z0-9-]{1,48}[a-zA-Z0-9]$/.test(slug) || \n         /^[a-zA-Z0-9]{1,50}$/.test(slug);\n}\n\n/**\n * Validate URL format and safety\n */\nexport function validateUrl(url: string): { valid: boolean; error?: string } {\n  // Check basic format\n  if (!url || typeof url !== 'string') {\n    return { valid: false, error: 'URL is required' };\n  }\n\n  // Max length check\n  if (url.length > 2048) {\n    return { valid: false, error: 'URL is too long (max 2048 characters)' };\n  }\n\n  // Parse URL\n  let parsed: URL;\n  try {\n    parsed = new URL(url);\n  } catch {\n    return { valid: false, error: 'Invalid URL format' };\n  }\n\n  // Only allow http/https schemes\n  const allowedSchemes = ['http:', 'https:'];\n  if (!allowedSchemes.includes(parsed.protocol)) {\n    return { valid: false, error: 'Only HTTP and HTTPS URLs are allowed' };\n  }\n\n  // Block dangerous patterns\n  const dangerousPatterns = [\n    /^javascript:/i,\n    /^data:/i,\n    /^file:/i,\n    /^vbscript:/i,\n  ];\n  \n  if (dangerousPatterns.some(pattern => pattern.test(url))) {\n    return { valid: false, error: 'URL contains disallowed scheme' };\n  }\n\n  return { valid: true };\n}\n\n/**\n * Hash an IP address for privacy-preserving analytics\n */\nexport function hashIP(ip: string, salt: string = 'shortfuse'): string {\n  return createHash('sha256')\n    .update(`${ip}:${salt}:${new Date().toISOString().split('T')[0]}`)\n    .digest('hex')\n    .substring(0, 16);\n}\n\n/**\n * Parse device type from user agent\n */\nexport function parseDevice(userAgent: string): string {\n  if (!userAgent) return 'unknown';\n  \n  const ua = userAgent.toLowerCase();\n  \n  if (/mobile|android|iphone|ipad|ipod|blackberry|windows phone/i.test(ua)) {\n    if (/tablet|ipad/i.test(ua)) return 'tablet';\n    return 'mobile';\n  }\n  \n  if (/bot|crawler|spider|slurp|googlebot|bingbot/i.test(ua)) {\n    return 'bot';\n  }\n  \n  return 'desktop';\n}\n\n/**\n * Extract country from CloudFront headers\n */\nexport function parseCountry(headers: Record<string, string>): string {\n  // CloudFront adds this header\n  return headers['cloudfront-viewer-country'] || \n         headers['cf-ipcountry'] || \n         'unknown';\n}\n\n/**\n * Create API response helper\n */\nexport function apiResponse(statusCode: number, body: any, headers: Record<string, string> = {}) {\n  return {\n    statusCode,\n    headers: {\n      'Content-Type': 'application/json',\n      'Access-Control-Allow-Origin': '*',\n      'Access-Control-Allow-Headers': 'Content-Type,Authorization',\n      ...headers,\n    },\n    body: JSON.stringify(body),\n  };\n}\n\n/**\n * Create redirect response\n */\nexport function redirectResponse(url: string, statusCode: 301 | 302 = 302, cacheSeconds: number = 60) {\n  return {\n    statusCode,\n    headers: {\n      'Location': url,\n      'Cache-Control': `public, max-age=${cacheSeconds}`,\n      'X-Robots-Tag': 'noindex',\n    },\n    body: '',\n  };\n}\n\n/**\n * Create error response\n */\nexport function errorResponse(statusCode: number, error: string, message: string) {\n  return apiResponse(statusCode, { error, message, statusCode });\n}\n\n/**\n * Extract user ID from Cognito JWT claims\n */\nexport function getUserIdFromEvent(event: any): string | null {\n  try {\n    // API Gateway HTTP API v2 format\n    const claims = event.requestContext?.authorizer?.jwt?.claims;\n    if (claims?.sub) {\n      return claims.sub;\n    }\n\n    // Fallback to v1 format\n    const authorizerClaims = event.requestContext?.authorizer?.claims;\n    if (authorizerClaims?.sub) {\n      return authorizerClaims.sub;\n    }\n\n    return null;\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Parse request body safely\n */\nexport function parseBody<T>(body: string | null | undefined): T | null {\n  if (!body) return null;\n  \n  try {\n    return JSON.parse(body) as T;\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Structured logger\n */\nexport const logger = {\n  info: (message: string, data?: Record<string, any>) => {\n    console.log(JSON.stringify({ level: 'INFO', message, ...data, timestamp: new Date().toISOString() }));\n  },\n  warn: (message: string, data?: Record<string, any>) => {\n    console.warn(JSON.stringify({ level: 'WARN', message, ...data, timestamp: new Date().toISOString() }));\n  },\n  error: (message: string, error?: Error, data?: Record<string, any>) => {\n    console.error(JSON.stringify({ \n      level: 'ERROR', \n      message, \n      error: error?.message, \n      stack: error?.stack,\n      ...data, \n      timestamp: new Date().toISOString() \n    }));\n  },\n};\n", "import crypto from 'crypto';\nconst rnds8Pool = new Uint8Array(256); // # of random values to pre-allocate\n\nlet poolPtr = rnds8Pool.length;\nexport default function rng() {\n  if (poolPtr > rnds8Pool.length - 16) {\n    crypto.randomFillSync(rnds8Pool);\n    poolPtr = 0;\n  }\n\n  return rnds8Pool.slice(poolPtr, poolPtr += 16);\n}", "import validate from './validate.js';\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nconst byteToHex = [];\n\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).slice(1));\n}\n\nexport function unsafeStringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];\n}\n\nfunction stringify(arr, offset = 0) {\n  const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!validate(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\nexport default stringify;", "import crypto from 'crypto';\nexport default {\n  randomUUID: crypto.randomUUID\n};", "import native from './native.js';\nimport rng from './rng.js';\nimport { unsafeStringify } from './stringify.js';\n\nfunction v4(options, buf, offset) {\n  if (native.randomUUID && !buf && !options) {\n    return native.randomUUID();\n  }\n\n  options = options || {};\n  const rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return unsafeStringify(rnds);\n}\n\nexport default v4;", "// Redirect Handler - Public, must be FAST\n// This Lambda handles the public redirect endpoint for short links\n\nimport type { APIGatewayProxyEventV2, APIGatewayProxyResultV2 } from 'aws-lambda';\nimport { getLinkBySlug, recordClickEvent, incrementClickCount } from '../lib/dynamodb.js';\nimport { \n  redirectResponse, \n  errorResponse, \n  hashIP, \n  parseDevice, \n  parseCountry,\n  logger \n} from '../lib/utils.js';\nimport { v4 as uuidv4 } from 'uuid';\n\nexport async function handler(event: APIGatewayProxyEventV2): Promise<APIGatewayProxyResultV2> {\n  const startTime = Date.now();\n  const slug = event.pathParameters?.slug;\n\n  logger.info('Redirect request', { slug, path: event.rawPath });\n\n  if (!slug) {\n    return errorResponse(400, 'BAD_REQUEST', 'Slug is required');\n  }\n\n  try {\n    // Get link from DynamoDB\n    const link = await getLinkBySlug(slug);\n\n    if (!link) {\n      logger.warn('Link not found', { slug });\n      return {\n        statusCode: 404,\n        headers: {\n          'Content-Type': 'text/html',\n          'Cache-Control': 'no-cache',\n        },\n        body: `\n          <!DOCTYPE html>\n          <html>\n            <head>\n              <title>Link Not Found - ShortFuse</title>\n              <meta name=\"robots\" content=\"noindex\">\n              <style>\n                body { font-family: system-ui, sans-serif; display: flex; align-items: center; justify-content: center; min-height: 100vh; margin: 0; background: #0f172a; color: #e2e8f0; }\n                .container { text-align: center; padding: 2rem; }\n                h1 { font-size: 4rem; margin: 0; color: #f97316; }\n                p { font-size: 1.25rem; color: #94a3b8; }\n                a { color: #f97316; text-decoration: none; }\n              </style>\n            </head>\n            <body>\n              <div class=\"container\">\n                <h1>404</h1>\n                <p>This short link doesn't exist.</p>\n                <p><a href=\"https://${process.env.APP_DOMAIN || 'app.shortfuse.io'}\">Create your own short links \u2192</a></p>\n              </div>\n            </body>\n          </html>\n        `,\n      };\n    }\n\n    // Check if link is enabled\n    if (!link.enabled) {\n      logger.warn('Link disabled', { slug, linkId: link.id });\n      return {\n        statusCode: 410,\n        headers: {\n          'Content-Type': 'text/html',\n          'Cache-Control': 'no-cache',\n        },\n        body: `\n          <!DOCTYPE html>\n          <html>\n            <head>\n              <title>Link Disabled - ShortFuse</title>\n              <meta name=\"robots\" content=\"noindex\">\n              <style>\n                body { font-family: system-ui, sans-serif; display: flex; align-items: center; justify-content: center; min-height: 100vh; margin: 0; background: #0f172a; color: #e2e8f0; }\n                .container { text-align: center; padding: 2rem; }\n                h1 { font-size: 2rem; margin: 0 0 1rem; color: #f97316; }\n                p { color: #94a3b8; }\n              </style>\n            </head>\n            <body>\n              <div class=\"container\">\n                <h1>Link Disabled</h1>\n                <p>This short link has been disabled by its owner.</p>\n              </div>\n            </body>\n          </html>\n        `,\n      };\n    }\n\n    // Check if link is expired\n    if (link.expiresAt && link.expiresAt < Date.now()) {\n      logger.warn('Link expired', { slug, linkId: link.id, expiresAt: link.expiresAt });\n      return {\n        statusCode: 410,\n        headers: {\n          'Content-Type': 'text/html',\n          'Cache-Control': 'no-cache',\n        },\n        body: `\n          <!DOCTYPE html>\n          <html>\n            <head>\n              <title>Link Expired - ShortFuse</title>\n              <meta name=\"robots\" content=\"noindex\">\n              <style>\n                body { font-family: system-ui, sans-serif; display: flex; align-items: center; justify-content: center; min-height: 100vh; margin: 0; background: #0f172a; color: #e2e8f0; }\n                .container { text-align: center; padding: 2rem; }\n                h1 { font-size: 2rem; margin: 0 0 1rem; color: #f97316; }\n                p { color: #94a3b8; }\n              </style>\n            </head>\n            <body>\n              <div class=\"container\">\n                <h1>Link Expired</h1>\n                <p>This short link has expired.</p>\n              </div>\n            </body>\n          </html>\n        `,\n      };\n    }\n\n    // Record analytics asynchronously (don't wait for it)\n    if (!link.privacyMode) {\n      const headers = event.headers || {};\n      \n      // Fire and forget - don't block the redirect\n      Promise.all([\n        recordClickEvent({\n          eventId: uuidv4(),\n          linkId: link.id,\n          slug: link.slug,\n          userId: link.userId,\n          timestamp: Date.now(),\n          referrer: headers['referer'] || headers['Referer'],\n          userAgent: headers['user-agent'] || headers['User-Agent'],\n          country: parseCountry(headers),\n          device: parseDevice(headers['user-agent'] || headers['User-Agent'] || ''),\n          ipHash: hashIP(event.requestContext?.http?.sourceIp || ''),\n        }),\n        incrementClickCount(link.userId, link.id),\n      ]).catch(err => {\n        logger.error('Failed to record analytics', err);\n      });\n    }\n\n    const duration = Date.now() - startTime;\n    logger.info('Redirect successful', { \n      slug, \n      linkId: link.id, \n      redirectType: link.redirectType,\n      duration \n    });\n\n    // Return redirect response\n    // Use shorter cache for 302 (temporary), longer for 301 (permanent)\n    const cacheSeconds = link.redirectType === 301 ? 300 : 60;\n    \n    return redirectResponse(link.longUrl, link.redirectType, cacheSeconds);\n  } catch (error) {\n    logger.error('Redirect error', error as Error, { slug });\n    return errorResponse(500, 'INTERNAL_ERROR', 'An error occurred processing your request');\n  }\n}\n"],
  "mappings": "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",
  "names": ["DynamoDBClient", "DynamoDBDocumentClient", "GetCommand", "PutCommand", "UpdateCommand", "QueryCommand", "TransactWriteCommand", "client", "docClient", "LINKS_TABLE", "ANALYTICS_TABLE", "AGGREGATES_TABLE", "getLinkBySlug", "slug", "slugResult", "linkId", "userId", "linkResult", "itemToLink", "incrementClickCount", "userId", "linkId", "docClient", "UpdateCommand", "LINKS_TABLE", "recordClickEvent", "event", "date", "monthKey", "PutCommand", "ANALYTICS_TABLE", "updateAggregates", "dayKey", "AGGREGATES_TABLE", "itemToLink", "item", "createHash", "randomBytes", "hashIP", "ip", "salt", "createHash", "parseDevice", "userAgent", "ua", "parseCountry", "headers", "apiResponse", "statusCode", "body", "redirectResponse", "url", "cacheSeconds", "errorResponse", "error", "message", "logger", "message", "data", "error", "crypto", "rnds8Pool", "poolPtr", "rng", "byteToHex", "i", "unsafeStringify", "arr", "offset", "crypto", "native_default", "v4", "options", "buf", "offset", "native_default", "rnds", "rng", "unsafeStringify", "v4_default", "handler", "event", "startTime", "slug", "logger", "errorResponse", "link", "getLinkBySlug", "headers", "recordClickEvent", "v4_default", "parseCountry", "parseDevice", "hashIP", "incrementClickCount", "err", "duration", "cacheSeconds", "redirectResponse", "error"]
}
